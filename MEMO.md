# v100以後の改版メモ

### '@', '!' fetchとdeposit

base.dict にエントリ2つを追加した。

### pop

base.dictのpopエントリに add.b #2,%a5を入れた。

### スタックアンダーフローチェック

narrowroad.sのdump_stackの最初でアンダーフローをチェックしてエラーメッセージを出した。

### putnum を直した(11/18)。

桁0だけ表示されないバグを直した。素直に下の桁からバッファに蓄え、最後にまとめて出力するようにした。divu.w命令を使った。上位16bitに余り、下位16bitに商が返される。

現在、signed short 16bitとして表示する(-32768 - 32767の範囲)。

linbuf末尾からASCII数字列を格納するようにしている。

### 数値出力: 10進固定小数点数

固定小数点数を使うときに実装しましょう。後送り。

### TYPEBルーチン

メモリ上のデータを空白が出るまで出力する。

### 現状のメモリマップ(11/20)

codes.sの先頭と、リンカスクリプト(`trip.ldscript`)による

機械語コード4kB, 辞書4kBを想定している。

0000-0FFF: リセットベクタ、割り込みベクタ、ほか
1000-1FFF: CODEセグメント、機械語コード
  code_top:
  ram_top:
2000-2FFF: DICTセグメント、base.dictをアセンブリコードに変換したdict.sが置かれる。
3000-FFFF: BUFFERセグメント
  linbuf:  3000-307F(128bytes)
  wordbuf: 3080-30FF(128bytes)
  putnumbuf: 3100-310F(16bytes)
    これはwordbufの末尾16バイトでも構わない。
FC00-FEFF: STACKセグメント
  data stack:   FC00-FCFF(%a5)
  return stack: FD00-FDFF(%a6)
  assembly stack: FE00-FEFF(%a7)

### 辞書エントリ追加(11/20)

@は奇数アドレスの時バスエラーを起こす。
C@, C!を追加した。バイトアクセス

### word定義、辞書検索がうまく働いていない(11/20)。

* 起動直後、cr, blは動作する。
* add呼び出し→add not found, 以後cr, blともにnot foundとなる。
  add,abc呼び出し後もだめ。inner interpreterが動作していない様子。デバッグ必要。
* abcが動作しない。nop not foundが出る。

調査の結果、

* 偶数長の比較がおかしい。文字列は先頭に長さ、２バイト名後に文字列データを置く。高速化のためword比較なので、偶数長の場合、末尾１バイトに何を詰めるかまでコントロールせねばならない。
* Moore師匠によれば、
  + 行入力からワードを切り出すWORDルーチンでは、文字列の次の空白文字までバッファに置くようにする。
  + 辞書エントリの文字列も、詰め文字は空白文字とする。

番兵、ですね。

今は計算機資源に余裕があるので、数10命令増えようが「文字列の意味を忠実に実装する」のですが、当時はこういう技をよく使いました。

### word定義・検索関連の修正(11/26)

ということで、以下の修正を施しました。

* 辞書エントリの文字列長さが偶数の時、文字列末尾に空白文字を追加した。偶数バイト長のとき、先頭の文字数１バイトも含めてワードアライメントで次のデータを置くと１バイト空きがでる。この１バイトが従来バイト0だったのを、空白文字を置くように辞書コンパイラを修正した。
  + do_same: 文字列比較時のワード数カウンタ初期化を修正した。というかもともと間違っていた。  
  + do_same: %d0へのバイトリードのあと、bit8-15のクリアをしていなかった。ここ68kアセンブリで要注意。`eor.w #0,%d0`を追加。

```
    +2    ÷2
  1 --> 3 --> 1
  2 --> 4 --> 2
  3 --> 5 --> 2
  4 --> 6 --> 3
  5 --> 7 --> 3
  ...
```

  + makedict.sh: awkスクリプトでアセンブリ命令列を出している。文字列は`.ascii`疑似命令で出しているが、偶数文字の文字列は末尾に' 'を追加した。
  + acceptルーチン: 行入力ルーチン。読み込み完了(`\r`検知)し、戻る前にバッファ末尾に無条件に空白文字を足した。乱暴だが。
  + dictdump.c: デバッグ用の辞書ダンプリスト生成用のプログラムも辞書エントリの文字列部分の長さ計算を修正した。

### その他の修正(11/26)

* 辞書エントリ: `base`を追加。数値出力の基数を格納する変数のアドレスをスタックに置く。`!`, `@`と組み合わせて使用する。まだ動作している感じがしない。デバッグ要。
* 辞書エントリ生成: 空の`dc.w`疑似命令が出ていた。理由は謎。とりあえず`dc.w`のオペランド文字列が空の時には生成しないようにした。乱暴。
* ブレークポイント機能: アセンブリ言語ソース中に `br[0-9][0-9]*`(b,r,数字)に一致するラベルがあれば、そのラベルすべてをブレークポイントとみなすようにした。
  + ソースコード中でブレークポイント入れたいところに`bp000:`と書く。`do_same`ルーチンにブレークポイント入れるときはこんな感じで。

```
do_same:
bp000:
    move.w  %d1,-(%a7)      /* push %d1 */
    move.w  %a1,-(%a7)
    move.w  %a0,-(%a7)
```

  + `extract_bp.sh`: 生成後のオブジェクトからシンボルリストを出し、そこに`br[0-9]`に一致するシンボルがあれば、そのアドレスを`PXXXX`の形式で出力する。この出力を `bp.X`ファイルとして保持し、ターゲットにアップロードする。
  + 68000エミュレータMusashi: 複数引数でアップロードファイルを指定できるように修正。
  + 実行時: `./sim narrowroad.X bp.X`と2ファイル指定して呼び出す。
* シングルステップ機能: Musashiに追加、ブレーク停止中はレジスタダンプしてキー入力待ちになる。スペースを叩くとワンステップ、`.`を入力すると実行再開。

### バグか？baseを変更後、2度目のbaseが読み込めない。

```
;
run...]16 base !
]base

se not found
00BA ].
BA]
```

`16 base !`で基数を16に切り替えたのち、`base`に値が正しく設定されているかどうかを確認しようと`base`と入力した。すると、`se not found`と出てスタックに`BA`が置かれた。なんで？

辞書引き、ワード切り出しの不具合を疑いトレースした結果、この挙動は「期待通り」(もしくは「書いた通り」)であることが分かった。すなわち、

* 基数を16としたことで、`A`, `B`は数値となる。
* なので`base`は数字から始まっていると見なし、`ba`を16進0xbaと見なしてスタックに`BA`を載せる。
* 次の文字`s`で数値でないと見なして数値変換(do_number)を抜けてワード検索に移動する。
* 残り2文字`se`を切り出して辞書検索に入り、`se not found`となった。

だった。だがこの挙動は許容できない。設計がおかしい。

baseは16進文字から始まっているが、ワードとして見ると16進数ではないだろう。現状は、数字文字なら数値に変換してゆくが、まず空白文字でワードを切り出してから変換すべきではないか。うーん、そういえばMoore師匠はnumber, wordをしっかり作れと言っていたなぁ。師匠の教えに立ち返ってみよう。

再度、Moore師匠の教えに立ち返ると、8.1 ワードの解剖(word dissection)にそれらしいことが書いてある。

> 以下の文字列全てがワードとなるような単純なルールはない。  
> * HELLO GOOD-BY 3.14 I.B.M. -.5 1.E03  
> 同様に、以下の文字列を意図するワードに分離する単純なルールもない。  
> * -ALPHA 1+ ALPHA+BETA +X**-3 X,Y,Z; X.OR.Y  
> 遅くなるが「スペースで終わるワードを読み、辞書を引き、数字に変換する。この定義でワードでない場合は、最後の文字を削除して再試行します。最終的には残った文字がワードとなるように、十分な文字を削除する。

要するに、
* 現状は、「数値変換、ワード切り出しと検索」、の順に処理しているが、
* これを「ワード切り出し、辞書検索、数値変換」の順に変える。
* 数値にもならないなら末尾1文字を削除して再度回す。

ということだ。ここでも、まずワードを切り出すと言っている。

とりあえず、「ワード切り出し、辞書検索、数値変換」に変更することにする。

### outer ループ組み換え(11/26)

組んでみた。当然だが動かない。
```
;
run...]1
0001 ]2
0001 0002 ]+

N not found
0003 ]pop
```
`N not found`が出るが、1 + 2 は実行できている。
```
0003 ]pop

 ]1Attempted to write 31 to RAM address 00fe3000
At 133a: move.b  D0, (A1,D1.l)
```
`pop`を入れるとプロンプトを返すが、1文字`1`を入力した時点でシミュレータが堕ちる。
```
kuma@LizNoir:~/narrowroad-m68k$ ;
run...]1 2 + .
0001 ]
```
1行に複数ワードがある場合そもそも続きを解釈しない。

