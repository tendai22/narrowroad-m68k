#
# base.dict .... makedict.sh sample dictionary template
#

    org 0
/*
 * test entries
 */
word abc
    lit
    1
    lit
    50
    add
    endword
code defgh
    mov.w  #1,-(%a5)        /* a5 is DSP */
    mov.w  #2,-(%a5)
    mov.w  (%a5)+,%d0
    add.w  (%a5)+,%d0
    mov.w  %d0,-(%a5)
    endcode
word test
    nop
    abc
    endword
code add
    jmp  do_plus
    
word nop
    endword

/*
 * primitive words
 */
code dup 
    move.w  (%a5),-(%a5)
    endcode
code over
    move.w  +2(%a5),-(%a5)
    endcode
code drop
    add.w   #2,%a5
    endcode
code swap
    move.w  (%a5)+,%d0
    move.w  (%a5)+,%d1
    move.w  %d0,-(%a5)
    move.w  %d1,-(%a5)
    endcode
code rot
    move.w  (%a5)+,%d0  /* n */
    move.w  (%a5)+,%d1  /* m */
    move.w  (%a5)+,%d2  /* l */
    move.w  %d1,-(%a5)
    move.w  %d0,-(%a5)
    move.w  %d2,-(%a5)
    endcode

/*
 * binary operators
 */
code + plus
    move.w  (%a5)+,%d0
    add.w   (%a5)+,%d0
    move.w  %d0,-(%a5)
    endcode
/*
 * print words
 */
code . period
    move.w  (%a5)+,%d0
    jsr     (do_putnum)
    endcode
code cr
    move.b  #13,%d0
    jsr     (putch)
    move.b  #10,%d0
    jsr     (putch)
    endcode
code space
    move.b  #' ',%d0
    jsr     (putch)
    endcode
code bl
    move.w  #' ',-(%a5)
    endcode

code typeb
    move.w  (%a5)+,%a0
    jsr     (typeb_sub)
    endcode
code types
    move.w  (%a5)+,%a0
    jsr     (putstr)
    endcode

/*
 * memory access
 */
code @ atfetch
    move.w  (%a5),%a0
    move.w  (%a0),%d0
    move.w  %d0,(%a5)
    endcode
code C@ bytefetch
    move.w  (%a5),%a0
    move.b  (%a0),%d0
    and.w   #255,%d0
    move.w  %d0,(%a5)
    endcode
code ! exclamation
    move.w  (%a5)+,%a0
    move.w  (%a5)+,%d0
    move.w  %d0,(%a0)
    endcode
code C! bytedeposite
    move.w  (%a5)+,%a0
    move.w  (%a5)+,%d0
    move.b  %d0,(%a0)
    endcode

/*
 * base ... number/period base number
 */
code base
    move.w  #__base,-(%a5)
    endcode

/*
 * here ... push next to end-of-the-last entry
 */
code here
    move.w  (here_addr),-(%a5)
    endcode
/*
 * last ... push the address of the last entry
 */
code last
    move.w  #last_addr,-(%a5)
    endcode
/*
 * where ... type name of last entry
 */
word where
    last        // 最終辞書エントリの先頭アドレス
    atfetch     // を取り出しスタックに乗せる
    dup
    lit
    1
    add         // アドレスを1足して文字列先頭を指す
                // ようにする。
    swap        // それをプッシュして
    bytefetch   // 文字数カウンタを取り出し
    lit
    31          
    and         // 0x1fでANDする(上3ビットをクリアする)
    type0       // これでスタックトップが(addr n)になった
                // のでtype0を呼び出す
    endword

/*
 * logical binary operators
 */

code and
    move.w  (%a5)+,%d0
    and.w   %d0,(%a5)
    endcode
code or
    move.w  (%a5)+,%d0
    or.w   %d0,(%a5)
    endcode
code xor
    move.w  (%a5)+,%d0
    eor.w   %d0,(%a5)
    endcode
/*
 * not ... logical inversion, not 0 if 0, 0 if not 0
 */

code not
    move.w  (%a5),%d0
    and.w   %d0,%d0
    beq     xcode_1
    move.w   #-1,%d0
xcode_1:
    add.w   #1,%d0
    move.w  %d0,(%a5)
    endcode

/*
 * type0 (addr n -- )
 */
code type0
    move.w  (%a5)+,%d1
    move.w  (%a5)+,%a0
    cmp.b   #0,%d1
type0_1:
    beq     type0_2
    move.b  (%a0)+,%d0
    jsr     (putch)
    add.b   #-1,%d1
    bra.b   type0_1
type0_2:
    endcode
/*
 * test words again
 */
word branch
    bne
    12
    lit
    #false_str
    types
    cr
    bra
    8
    lit
    #true_str
    types
    cr
    endword
word ttest
    lit
    #true_str
    types
    endword

