# v100 以後のタスク・仕様

## バグフィックス

* 10 . が 1になる。
* 101 . 11になる。
* 12001 . 121になる。
これを直す。

## 名詞と動詞(3.1)

* `@` スタック上のアドレスをその内容で置き換える。 
* `=` スタック上のアドレスに、スタック上のアドレスのすぐ下の値を入れる 


## 3.2 制御ループ

* パラメータスタックが限界を越えていないかのチェック
* 外部インタプリタの戻りポイントは２つ、
  + スタックを使用するルーチンのみチェックする
  + チェックする口としない口
  + ループの実行効率を追求するため
* エラールーチン
  + 「問題のあるワード」と「エラーメッセージ」を印字する。
  + (サブルーチンのリターン階層ごとにエラーフラグをチェックすることを避ける)
  + リターンスタックをクリアする(longjmp風)
  + 例1: ワードを間違えた→そのワード+"?"
  + 例2: 加算時にスタックに1引数しかない→そのワード+"LIMIT!"
* スタックの配置
  + パラメータスタックをリターンスタックにオーバフローさせる  
    →リターンスタックの後ろにパラメータスタックを置く
  + パラメータスタックをメッセージバッファにアンダーフローさせる  
    →パラメータスタックの後ろにメッセージバッファを置く


## 3.3 WORDの定義

## メッセージバッファ(3.3.1)

* 十分な長さを確保する←128byteとする。

## WORD (3.3.1, 3.3.2)

* バッファリングのエミュレーションを行う。
* バックスペース文字とキャンセル文字をサポートする。
* end-of-message wordを最後に置く
←EOM文字から成るワードを定義する必要がある。
これで何を行うのか不明。
* end-of-message word: OKというワードをタイプしてQUERYにジャンプする辞書エントリを持っている(6章)。
* 出力バッファ。複数のうちどれか一つでもバッファドであればすべての出力デバイスをバッファドとして扱うべきで、ノンバッファのデバイスではバッファドのエミュレーションを行う。
* 入力バッファと出力バッファは同じ領域を使用する。相互に排他的なはず。
* メッセージバッファがまだ入力を保持しているかどうかを表すフラグ(1bit)は必要だ。出力データを印字する際にはこのフラグをクリアする。
* `FETCH`: 入力ポインタが指す文字をロードしレジスタに格納し、入力ポインタを1つ進める。
* `DEPOSIT`: レジスタ中の文字を出力バッファに書き出し、出力ポインタを1つ進める。

## NUMBER (3.4, 3.4.1) 10進変換

`NUMBER`サブルーチンのガイドライン。

* 整数と負の整数は常に定義すること、
* 先頭のプラス記号を許容しないこと、先頭のプラス記号は数値としての意味を持たせないこと、かつ、ワードとしては使えること
* 浮動小数点ハードウェアがある場合は、小数点の有無で浮動小数点数を区別すること、
* 浮動小数点ハードウェアがないならば、小数点がある場合は固定小数点数とみなし、浮動小数点数シミュレーションをしないこと、
* 1未満の小数に指数をつけないこと、

## NUMBER (3.4.2)

`SIGNED`: 次の文字がマイナスかどうかをテストし、スイッチを設定し、これまでの数をゼロにして`NATURAL`に落ちます。

`NATURAL`: 文字を取得し、それが数字であるかどうかをテストし、これまでの数を10倍し、その数字を加算します。これは数字でないものを見つけるまで繰り返されます。

* まず`SIGNED`を呼び出す。その中で、
* 符号を表すスイッチを設定する。
* (`NATURAL`に流れる)整数変換を行う(この値が整数部分になる)
* `SIGNED`の停止文字が`.`ならば、再度`NATURAL`を呼び出し小数部分を変換する。
* 整数部分と小数部分を、最後に浮動小数点数または固定小数点数に変換する。  
  (固定小数点数の場合は、桁数を表す変数が別途あるはず)

> 桁数を表す変数の名前がまだ分かっていない

* 10進固定小数点数の桁数を表すフィールドは`D`だそうな。

## 数値出力(3.4.3)

* 10で割って余りを保存し、を繰り返す。
* いったんバッファに置く、保存場所はメッセージバッファの末尾、またはスタックでもよい。
* 最終的に`TYPEB`サブルーチンを使って数値を印字することができる。
* `TYPEB`サブルーチン: 文字列をスペースが出てくるまで出力する。スペースも合わせて出力する。
* `D`: 小数点以下の桁数を指定するフィールド、入力と出力で同じ桁数を使用する。
* `F`: 数値カラム幅を指定する(右寄せ出力の際のカラム幅)
* `SPACE`: 指定した数のスペース文字を印字する。負の値ならは出力ポインタを変更して後方に移動させる(ここ意味不明)
* tab entry (`TAB`?)

## スタック(3.5)

* リターンスタック: 余裕があればインデクスレジスタを割り当てるべき。8レベルもあれば十分
* パラメータスタック: 余裕があればインデクスレジスタを割り当てるべき。16レベルでは足りない。
* レジスタに余裕があれば、スタックトップを常時そのレジスタに取っておくと処理効率が上がる。
* トップワード、下位ワード: スタックの最上位2ワードを指す術語。

## 辞書(3.6)

* 辞書を一箇所に固めて置き、項目の形式を標準化することが重要です。
* ルーチン(機械語コード)それぞれにエントリを1つ割り当てること。
* IF ... ELSE IF 構文には、各エントリにルーチンを関連付けるという特徴があるということは重要(ここ意味不明、switch case 文の各case 節をそれぞれ辞書エントリ1つ割り当てるべきと言っているのか?)

### エントリの形式(3.6.1)

* 2つの方法がある、Mooreは2番目の方法をおすすめしている。
* エントリは可変長、一部は、コード、パラメータ、記憶領域となる。
* ワードフィールド: 1バイト目が長さ、2バイト目以後にそのワードの名前を持つ文字列。ワード(2バイト)アライメント。
* リンクフィールド: 2バイト、前のエントリ先頭を指すアドレス。上2ビットにフラグを用いる。よって辞書サイズは最大16kB
* コードフィールド: Moore師匠によると、コードのアドレスとあるが、今回は機械語コードを直接置いた。
* パラメータフィールド: 以下の4種類ある。
  + 数値、定数または変数: サイズは可変です。数値の性質は、そのエントリが実行するコードによって決定されます。 
  + 配列: 複数の数値が格納されるスペースです。配列のサイズはパラメータであるか、または実行するコードに含まれているかもしれません。 
  + 定義：仮想コンピュータの命令を表す辞書エントリの配列。3.9を参照してください。 
  + 機械語命令: プログラムによってコンパイルされたコードで、このエントリが実行される際にこのコードが実行されます。このようなデータは、おそらくワード境界でアラインされなければならないが、他はその必要はありません。

以下の方針で進める。

* 定数: コード`do_const`で、パラメータフィールドの先頭2バイトをスタックに積む。
* 変数: コード`do_var`で、パラメータフィールド先頭のアドレスをスタックに積む。つまり、変数のアドレスは、このワードエントリのパラメータフィールドである。
* 配列: コード`do_array`で、パラメータフィールド先頭2バイトが長さ、3バイト目以後が2バイト要素の列とする。`do_array`は配列の長さと先頭アドレスをスタックに積む。
* 定義: コード`do_list`で、パラメータフィールド先頭から2バイトずつ、他のエントリの先頭を指すアドレスの列である。列の最後は`do_exit`である。
* 機械語コード: コードフィールド先頭から機械語命令を並べてゆく。本ワードの機能を実行するコードです。最後はリターン命令でなく、`jmp do_next`である。

現在のところ、定義と機械語コードの辞書エントリのみ作成できる。`do_const`, `do_var`, `do_array`は今後実装する。

## 検索(3.6.2)

名前部分を可変長としているので、1バイト目を長さとしてワード比較を繰り返す。ここまでは既に実現できている。文字列末尾にスペースを置くかどうかまで考える。現在はスペースを置いていない。アセンブラのalign疑似命令に任せているので、おそらく0を詰められている。

現状のまま進める。後ろを読んで決める。多分仕様を変更することになる。

## 初期化(3.6.3)

制御ループに入るまでの処理を書く。当然すでにある。現状のまま進める。

## エントリの定義(4.1)

* ワード`ENTRY`: 次のワードを読み取り、そのワードをワードフィールドとする辞書エントリを作成する。コードのアドレスをパラメータとして渡す。パラメータフィールドを除くすべてのフィールドを作成する。

> コードのアドレスをどの形式で渡すか。現在は、機械語そのものを置いている。do_listならば、`jmp do_list`のジャンプ命令を置いている。`do_list`のアドレスを置いて、インナーインタプリタではさらにdereferenceするようにすべき。

* エントリの抹消
* `REMEMBER HERE`

## 演算(4.3)

* TRUEは1、FALSEは0
* 単項演算子
  * MINUS は top の符号を変更します。 
  * ABSは符号を正にします。 
  * ZERO は、top が0の場合、それを TRUE で置き換えます。さもなくば、FALSEをスタックに置きます。 
  * NONZERO は、top が 0 でない場合、TRUE をスタックに配置します。さもなくば、それをそのままにしておきます(FALSEをスタックに残します)。
* 二項演算子
  * \+ lowerにtopを足す。 
  * \* lowerにtopを掛ける。 
  * \- lowerからtopを引く。 
  * / lowerをtopで割って、商を残す。 
  * MOD lowerをtopで割って、余りを残す。 
  * MAX topがlowerより大きい場合、lowerをtopで置き換えます。 
  * MIN topがlowerより小さい場合、lowerをtopで置き換えます。 
  * \** lowerをtop乗する。

* 関係演算
  * = それらは等しいか?  
  * < topはlowerより大きいか?
  * \> topはlowerより小さいか?  
  * \>= は top が lower より大きくないか?  
  * <= top は lower より小さくないか? 

* 論理演算
  * NOT topがFALSEの場合はTRUEに、それ以外の場合はFALSEに置き換えます。 
  * OR 論理和演算  
  * AND 論理積演算 
  * IMP 論理包含(lowerが偽またはtopが真のときに真となる)  
  * XOR 論理的排他的論理和 

* 数値型ごとの演算
  * `+` 整数と固定小数点数の加算(これらは同じです)。 
  * `+F` 浮動小数点数の加算   
  * `+D` 倍精度の加算。

  68000版では浮動小数点数は使わない。`+`, `+D`のみ導入する。

## 定義エントリ(4.4)

* `:`. `;`エントリ
* `:`
  + アドレス`EXECUTE`を`ENTRY`サブルーチンに渡します。
  + スイッチ`STATE`をセットします。
  + (制御ループの変更) `STATE`が0であれば、すでに説明したようにワードが実行され、1であればワードがコンパイルされる、というように制御ループを変更する
  + ワードの実行の方の効率が良くなるようにする。
  + パラメータフィールド: ワードを辞書で検索し、このアドレスをパラメータフィールドに格納する。辞書に書き込むメカニズムは既に持っている(どれ?`DP`?)
  + パラメータフィールドに書き込むアドレスは、エントリ自体のアドレスを書き込む。コードのアドレスではない。

  > 現在はコードのアドレスを書き込んでいる。内部インタプリタも改造必要。

