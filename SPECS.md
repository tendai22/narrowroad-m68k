# v100 以後のタスク・仕様

## バグフィックス

* 10 . が 1になる。
* 101 . 11になる。
* 12001 . 121になる。
これを直す。

## 名詞と動詞(3.1)

* `@` スタック上のアドレスをその内容で置き換える。 
* `=` スタック上のアドレスに、スタック上のアドレスのすぐ下の値を入れる 


## 3.2 制御ループ

* パラメータスタックが限界を越えていないかのチェック
* 外部インタプリタの戻りポイントは２つ、
  + スタックを使用するルーチンのみチェックする
  + チェックする口としない口
  + ループの実行効率を追求するため
* エラールーチン
  + 「問題のあるワード」と「エラーメッセージ」を印字する。
  + (サブルーチンのリターン階層ごとにエラーフラグをチェックすることを避ける)
  + リターンスタックをクリアする(longjmp風)
  + 例1: ワードを間違えた→そのワード+"?"
  + 例2: 加算時にスタックに1引数しかない→そのワード+"LIMIT!"
* スタックの配置
  + パラメータスタックをリターンスタックにオーバフローさせる  
    →リターンスタックの後ろにパラメータスタックを置く
  + パラメータスタックをメッセージバッファにアンダーフローさせる  
    →パラメータスタックの後ろにメッセージバッファを置く


## 3.3 WORDの定義

## メッセージバッファ(3.3.1)

* 十分な長さを確保する←128byteとする。

## WORD (3.3.1, 3.3.2)

* バッファリングのエミュレーションを行う。
* バックスペース文字とキャンセル文字をサポートする。
* end-of-message wordを最後に置く
←EOM文字から成るワードを定義する必要がある。
これで何を行うのか不明。
* end-of-message word: OKというワードをタイプしてQUERYにジャンプする辞書エントリを持っている(6章)。
* 出力バッファ。複数のうちどれか一つでもバッファドであればすべての出力デバイスをバッファドとして扱うべきで、ノンバッファのデバイスではバッファドのエミュレーションを行う。
* 入力バッファと出力バッファは同じ領域を使用する。相互に排他的なはず。
* メッセージバッファがまだ入力を保持しているかどうかを表すフラグ(1bit)は必要だ。出力データを印字する際にはこのフラグをクリアする。
* `FETCH`: 入力ポインタが指す文字をロードしレジスタに格納し、入力ポインタを1つ進める。
* `DEPOSIT`: レジスタ中の文字を出力バッファに書き出し、出力ポインタを1つ進める。

## NUMBER (3.4, 3.4.1) 10進変換

(POLを読んで埋める)

## NUMBER (3.4.2)

`SIGNED`: 次の文字がマイナスかどうかをテストし、スイッチを設定し、これまでの数をゼロにして`NATURAL`に落ちます。

`NATURAL`: 文字を取得し、それが数字であるかどうかをテストし、これまでの数を10倍し、その数字を加算します。これは数字でないものを見つけるまで繰り返されます。

* まず`SIGNED`を呼び出す。その中で、
* 符号を表すスイッチを設定する。
* (`NATURAL`に流れる)整数変換を行う(この値が整数部分になる)
* `SIGNED`の停止文字が`.`ならば、再度`NATURAL`を呼び出し小数部分を変換する。
* 整数部分と小数部分を、最後に浮動小数点数または固定小数点数に変換する。  
  (固定小数点数の場合は、桁数を表す変数が別途あるはず)

> 桁数を表す変数の名前がまだ分かっていない

* 10進固定小数点数の桁数を表すフィールドは`D`だそうな。

## 数値出力

* 10で割って余りを保存し、を繰り返す。
* いったんバッファに置く、保存場所はメッセージバッファの末尾、またはスタックでもよい。
* 最終的に`TYPEB`サブルーチンを使って数値を印字することができる。
* `TYPEB`サブルーチン: 文字列をスペースが出てくるまで出力する。スペースも合わせて出力する。
* `D`: 小数点以下の桁数を指定するフィールド、入力と出力で同じ桁数を使用する。
* `F`: 数値カラム幅を指定する(右寄せ出力の際のカラム幅)
* `SPACE`: 指定した数のスペース文字を印字する。負の値ならは出力ポインタを変更して後方に移動させる(ここ意味不明)
* tab entry (`TAB`?)

## スタック

* リターンスタック: 余裕があればインデクスレジスタを割り当てるべき。8レベルもあれば十分
* パラメータスタック: 余裕があればインデクスレジスタを割り当てるべき。16レベルでは足りない。
* レジスタに余裕があれば、スタックトップを常時そのレジスタに取っておくと処理効率が上がる。
* トップワード、下位ワード: スタックの最上位2ワードを指す術語。

## 辞書

* 辞書を一箇所に固めて置き、項目の形式を標準化することが重要です。
* ルーチン(機械語コード)それぞれにエントリを1つ割り当てること。
* IF ... ELSE IF 構文には、各エントリにルーチンを関連付けるという特徴があるということは重要(ここ意味不明、switch case 文の各case 節をそれぞれ辞書エントリ1つ割り当てるべきと言っているのか?)

### エントリの形式

* 2つの方法がある、Mooreは2番目の方法をおすすめしている。
* エントリは可変長、一部は、コード、パラメータ、記憶領域となる。
* ワードフィールド: 1バイト目が長さ、2バイト目以後にそのワードの名前を持つ文字列。ワード(2バイト)アライメント。
* リンクフィールド: 2バイト、前のエントリ先頭を指すアドレス。上2ビットにフラグを用いる。よって辞書サイズは最大16kB
* コードフィールド: Moore師匠によると、コードのアドレスとあるが、今回は機械語コードを直接置いた。
* パラメータフィールド: 以下の4種類ある。
  + 数値、定数または変数: サイズは可変です。数値の性質は、そのエントリが実行するコードによって決定されます。 
  + 配列: 複数の数値が格納されるスペースです。配列のサイズはパラメータであるか、または実行するコードに含まれているかもしれません。 
  + 定義：仮想コンピュータの命令を表す辞書エントリの配列。3.9を参照してください。 
  + 機械語命令: プログラムによってコンパイルされたコードで、このエントリが実行される際にこのコードが実行されます。このようなデータは、おそらくワード境界でアラインされなければならないが、他はその必要はありません。

以下の方針で進める。

* 定数: コード`do_const`で、パラメータフィールドの先頭2バイトをスタックに積む。
* 変数: コード`do_var`で、パラメータフィールド先頭のアドレスをスタックに積む。つまり、変数のアドレスは、このワードエントリのパラメータフィールドである。
* 配列: コード`do_array`で、パラメータフィールド先頭2バイトが長さ、3バイト目以後が2バイト要素の列とする。`do_array`は配列の長さと先頭アドレスをスタックに積む。
* 定義: コード`do_list`で、パラメータフィールド先頭から2バイトずつ、他のエントリの先頭を指すアドレスの列である。列の最後は`do_exit`である。
* 機械語コード: コードフィールド先頭から機械語命令を並べてゆく。本ワードの機能を実行するコードです。最後はリターン命令でなく、`jmp do_next`である。

現在のところ、定義と機械語コードの辞書エントリのみ作成できる。`do_const`, `do_var`, `do_array`は今後実装する。

## エントリの定義

* ワード`ENTRY`: 次のワードを読み取り、そのワードをワードフィールドとする辞書エントリを作成する。コードのアドレスをパラメータとして渡す。パラメータフィールドを除くすべてのフィールドを作成する。
